package main

import (
	"capnproto.org/go/capnp/v3"
	"capnproto.org/go/capnp/v3/rpc"
	"context"
	capnp_proto "github.com/shyamjesal/transfer-bench/capnp"
	log "github.com/sirupsen/logrus"
	"net"
)

// PacketServer satisfies the Arith_Server interface that was generated
// by the capnp compiler.
type PacketServer struct {
}

// Get is the concrete implementation of the Get method that was
// defined in the schema. Notice that the method signature matches that of
// the Arith_Server interface.
//
// The Arith_multiply struct was generated by the capnp compiler.  You will
// find it in arith.capnp.go
func (PacketServer) Get(ctx context.Context, call capnp_proto.Packet_get) error {
	res, err := call.AllocResults() // allocate the results struct
	if err != nil {
		return err
	}
	log.Info(call.Args().Key())

	// Set the result to be the product of the two arguments, A and B,
	// that we received. These are found in the Arith_multiply struct.
	res.SetPayload(payloadData)
	return nil
}

func serveWithCapnp() {
	listener, err := net.Listen("tcp", addr)
	if err != nil {
		log.Fatal(err)
	}

	// Instantiate a local ArithServer.
	server := PacketServer{}

	// Derive a client capability that points to the server.  Note the
	// return type of arith.ServerToClient.  It is of type arith.Arith,
	// which is the client capability.  This capability is bound to the
	// server instance above; calling client methods will result in RPC
	// against the corresponding server method.
	//
	// The client can be shared over the network.

	// Expose the client over the network.  The 'rwc' parameter can be any
	// io.ReadWriteCloser.  In practice, it is almost always a net.Conn.
	//
	// Note the BootstrapClient option.  This tells the RPC connection to
	// immediately make the supplied client -- an arith.Arith, in our case
	// -- to the remote endpoint.  The capability that an rpc.Conn exports
	// by default is called the "bootstrap capability".
	for {
		client := capnp_proto.Packet_ServerToClient(server)
		// accept connection
		conn, err := listener.Accept()
		if err != nil {
			log.Fatal(err)
		}
		go func() {
			capnpconn := rpc.NewConn(rpc.NewStreamTransport(conn), &rpc.Options{
				// The BootstrapClient is the RPC interface that will be made available
				// to the remote endpoint by default.  In this case, Arith.
				BootstrapClient: capnp.Client(client),
			})
			// Block until the connection terminates.
			select {
			case <-capnpconn.Done():
				capnpconn.Close()
			}
		}()
	}
}
